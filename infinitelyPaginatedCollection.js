// Generated by CoffeeScript 1.6.2
/*
 * This allows you to have an "infinitely paginated" Backbone collection,
 * IE, you can keep adding the contents of the next page to the collection
 * and only fetch the next page when you need to. Basically this is how
 * the Facebook news feed works - you scroll to the bottom and then it makes
 * a call to the server to get the next set of results.
 *
 * @author  Jason Raede <jason@torchedm.com>
*/


(function() {
  var InfinitelyPaginatedCollection, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  InfinitelyPaginatedCollection = (function(_super) {
    __extends(InfinitelyPaginatedCollection, _super);

    function InfinitelyPaginatedCollection() {
      _ref = InfinitelyPaginatedCollection.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    InfinitelyPaginatedCollection.prototype.resultsPerCall = 20;

    InfinitelyPaginatedCollection.prototype.sortColumn = 'id';

    InfinitelyPaginatedCollection.prototype.sortDirection = 'DESC';

    InfinitelyPaginatedCollection.prototype.comparator = function(model1, model2) {
      if (model1.get(this.sortColumn) < model2.get(this.sortColumn)) {
        return 1;
      } else if (model1.get(this.sortColumn) === model2.get(this.sortColumn)) {
        return 0;
      } else {
        return -1;
      }
    };

    InfinitelyPaginatedCollection.prototype.fetchPreviousModels = function(options) {
      var before, firstModel, success,
        _this = this;

      firstModel = this.at(0);
      if (firstModel) {
        before = firstModel.get(this.sortColumn);
      } else {
        before = null;
      }
      options = options ? _.clone(options) : {};
      if (options.parse === null) {
        options.parse = true;
      }
      success = options.success;
      options.data = {
        before: before,
        results_per_call: this.resultsPerCall
      };
      options.success = function(resp) {
        _this.add(resp, options);
        if (success) {
          success(_this, resp, options);
        }
        return _this.trigger('newPage', _this, resp, options);
      };
      return this.sync('read', this, options);
    };

    /*
    	 * Make a call to the server to get the models after the most recently fetched model
    */


    InfinitelyPaginatedCollection.prototype.fetchNextModels = function(options) {
      var after, lastModel, success,
        _this = this;

      lastModel = this.at(this.length - 1);
      if (lastModel) {
        after = lastModel.get(this.sortColumn);
      } else {
        after = null;
      }
      options = options ? _.clone(options) : {};
      if (options.parse === null) {
        options.parse = true;
      }
      success = options.success;
      options.data = {
        after: after,
        results_per_call: this.resultsPerCall
      };
      options.success = function(resp) {
        _this.add(resp, options);
        if (success) {
          success(_this, resp, options);
        }
        return _this.trigger('newPage', _this, resp, options);
      };
      return this.sync('read', this, options);
    };

    return InfinitelyPaginatedCollection;

  })(Backbone.Collection);

}).call(this);
